//===-- ConvertToMuxBuiltinsSYCLNativeCPU.cpp - Convert to Mux Builtins ---===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Converts SPIRV builtins to Mux builtins used by the oneAPI Construction
// Kit for SYCL Native CPU
//
//===----------------------------------------------------------------------===//

#include "llvm/SYCLLowerIR/ConvertToMuxBuiltinsSYCLNativeCPU.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/IR/Constant.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/TargetParser/Triple.h"
#include <map>

using namespace llvm;

namespace {

static void fixFunctionAttributes(Function *F) {
  // The frame-pointer=all and the "byval" attributes lead to code generation
  // that conflicts with the Kernel declaration that we emit in the Native CPU
  // helper header (in which all the kernel argument are void* or scalars).
  auto AttList = F->getAttributes();
  for (unsigned ArgNo = 0; ArgNo < F->getFunctionType()->getNumParams();
       ArgNo++) {
    if (AttList.hasParamAttr(ArgNo, Attribute::AttrKind::ByVal)) {
      AttList = AttList.removeParamAttribute(F->getContext(), ArgNo,
                                             Attribute::AttrKind::ByVal);
    }
  }
  F->setAttributes(AttList);
  F->addFnAttr("frame-pointer", "none");
}

// Builtin signature type
enum class BT_Sig {
  I64_I32,     // i64(i32)
  I32_void,    // i32()
  B1_I32_B1,   // B1(I32, B1)
  I32_I32_I32, // I32(I32, I32)
  F64_F64_I32, // F64(F64, I32)
  F64_F64_F64_I32, // F64(F64, F64, I32)
};

// Helper macros for constructing builtin MS names
#define GENMS_I64_I32(builtin_str) "?" builtin_str "@@YA_KXZ"
#define GENMS_I32_VOID(builtin_str) "?" builtin_str "@@YAIXZ"

#define LENCHECK(b_str, len) []() { static_assert(sizeof(b_str) == len + 1); }

#define GEN_IT_proc(b_str, len) (LENCHECK(b_str, len), "_Z" #len b_str "v")
#define GEN_p(b_str, len, ncpu_bstr, num)                                      \
  {                                                                            \
    {GEN_IT_proc(b_str, len), GENMS_I64_I32(b_str)}, {                         \
      ncpu_bstr, {                                                             \
        BT_Sig::I64_I32, { num }                                               \
      }                                                                        \
    }                                                                          \
  }
#define GEN_xyz(b_name, len, ncpu_name)                                        \
  GEN_p(#b_name "_x", len, #ncpu_name, 0),                                     \
      GEN_p(#b_name "_y", len, #ncpu_name, 1),                                 \
      GEN_p(#b_name "_z", len, #ncpu_name, 2)

#define GEN_u32(b_name, len, ncpu_name)                                        \
  {                                                                            \
    { GEN_IT_proc(#b_name, len), GENMS_I32_VOID(#b_name) }                     \
    , {                                                                        \
      #ncpu_name, {                                                            \
        BT_Sig::I32_void, {}                                                   \
      }                                                                        \
    }                                                                          \
  }

struct bt_info {
  BT_Sig type;
  unsigned args[1];
};

// Todo: replace this map with BC file generated by clang
static const std::pair<std::pair<StringRef, StringRef>,
                       std::pair<StringRef, bt_info>>
    BuiltinNamesMap[] = {
        GEN_xyz(__spirv_GlobalInvocationId, 28, __mux_get_global_id),
        GEN_xyz(__spirv_GlobalSize, 20, __mux_get_global_size),
        GEN_xyz(__spirv_GlobalOffset, 22, __mux_get_global_offset),
        GEN_xyz(__spirv_LocalInvocationId, 27, __mux_get_local_id),
        GEN_xyz(__spirv_NumWorkgroups, 23, __mux_get_num_groups),
        GEN_xyz(__spirv_WorkgroupSize, 23, __mux_get_local_size),
        GEN_xyz(__spirv_WorkgroupId, 21, __mux_get_group_id),
        // subgroup
        GEN_u32(__spirv_SubgroupLocalInvocationId, 33,
                __mux_get_sub_group_local_id), // check
        GEN_u32(__spirv_SubgroupMaxSize, 23, __mux_get_max_sub_group_size),
        GEN_u32(__spirv_SubgroupId, 18, __mux_get_sub_group_id),
        GEN_u32(__spirv_NumSubgroups, 20, __mux_get_num_sub_groups),
        GEN_u32(__spirv_SubgroupSize, 20, __mux_get_sub_group_size),
};

static inline bool isForVisualStudio(StringRef TripleStr) {
  llvm::Triple Triple(TripleStr);
  return Triple.isKnownWindowsMSVCEnvironment();
}

static constexpr char SPIRVBarrier[] = "_Z22__spirv_ControlBarrierjjj";
static constexpr char SPIRVBarrierWin[] = "?__spirv_ControlBarrier@@YAXIII@Z";
static constexpr char MuxBarrier[] = "__mux_work_group_barrier";

static FunctionType *getFuncType(BT_Sig FType, LLVMContext &Ctx) {
  switch (FType) {
  case BT_Sig::I64_I32:
    return FunctionType::get(Type::getInt64Ty(Ctx), {Type::getInt32Ty(Ctx)},
                             false);
  case BT_Sig::I32_void:
    return FunctionType::get(Type::getInt32Ty(Ctx), {}, false);
  case BT_Sig::B1_I32_B1:
    return FunctionType::get(Type::getInt1Ty(Ctx),
                             {Type::getInt32Ty(Ctx), Type::getInt1Ty(Ctx)},
                             false);
  case BT_Sig::I32_I32_I32:
    return FunctionType::get(Type::getInt32Ty(Ctx),
                             {Type::getInt32Ty(Ctx), Type::getInt32Ty(Ctx)},
                             false);
  case BT_Sig::F64_F64_I32: // F64(F64, I32)
    return FunctionType::get(Type::getDoubleTy(Ctx),
      { Type::getDoubleTy(Ctx), Type::getInt32Ty(Ctx) },
      false);
  case BT_Sig::F64_F64_F64_I32: // F64(F64, F64, I32)
    return FunctionType::get(Type::getDoubleTy(Ctx),
      { Type::getDoubleTy(Ctx), Type::getDoubleTy(Ctx), Type::getInt32Ty(Ctx) },
      false);
  }
  report_fatal_error("Unsupported Value in SYCL Native CPU\n");
  return nullptr;
}

Function *getReplaceFunc(Module &M, StringRef Name, BT_Sig FType) {
  LLVMContext &Ctx = M.getContext();
  auto *MuxFTy = getFuncType(FType, Ctx);
  auto F = M.getOrInsertFunction(Name, MuxFTy);
  return cast<Function>(F.getCallee());
}

Function *getMuxBarrierFunc(Module &M) {
  // void __mux_work_group_barrier(i32 %id, i32 %scope, i32 %semantics)
  LLVMContext &Ctx = M.getContext();
  auto *Int32Ty = Type::getInt32Ty(Ctx);
  auto *MuxFTy = FunctionType::get(Type::getVoidTy(Ctx),
                                          {Int32Ty, Int32Ty, Int32Ty}, false);
  auto F = M.getOrInsertFunction(MuxBarrier, MuxFTy);
  return cast<Function>(F.getCallee());
}

static constexpr const char *MuxKernelAttrName = "mux-kernel";

static void setIsKernelEntryPt(Function &F) {
  F.addFnAttr(MuxKernelAttrName, "entry-point");
}

static Function *getOrInsertWorkGroupBT(Module* M, StringRef MuxName, Type *T) {
  // Work group collectives have signature T (i32, T)
  auto *FTy = FunctionType::get(T, {Type::getInt32Ty(M->getContext()), T}, false);
  auto FCallee = M->getOrInsertFunction(MuxName, FTy);
  return dyn_cast<Function>(FCallee.getCallee());
}

static void processGroupCollective(Function *F, StringRef Name) {
  auto& Ctx = F->getParent()->getContext();
  // __spirv_Group(scope, operation, val)
  // scope:
  //  * 0: todo
  //  * 1: todo
  //  * 2: work group
  //  operation:
  //  * 0: reduce
  //  * 1: todo
  
  // Build work list of CallInst that we want to replace.
  std::map<CallInst*, Function*> WorkList;
  for(auto& U : F->uses()) {
    auto *CI = dyn_cast<CallInst>(U.getUser());
    if(!CI) {
      report_fatal_error("Unhandled value for SYCL Native CPU");
    }
    WorkList.insert(std::make_pair(CI, nullptr));
  }

  // Iterate over the Instructions and map them to the right mux builtin
  for(auto& Entry : WorkList) {
    auto *CI = Entry.first;
    auto* ScopeArg = CI->getArgOperand(0);
    auto* OperationArg = CI->getArgOperand(1);
    auto getIntValue = [](Value *V) {
      auto Const = dyn_cast<ConstantInt>(V);
      if(!Const) {
        report_fatal_error("Unhandled value for SYCL Native CPU");
      }
      return Const->getValue();
    };
    auto Scope = getIntValue(ScopeArg);
    auto Op = getIntValue(OperationArg);
    auto *T = CI->getArgOperand(2)->getType();
    // todo remove these once we support everything
    assert(Scope == 2 && Op == 0 && "Unsupported group collective");

    // Construct OCK function name 
    std::string Prefix;
    if(Scope == 2)
      Prefix = "__mux_work_group";
    std::string Operation;
    if(Op == 0)
      Operation = "_reduce";
    std::string Func;
    if(Name.starts_with("IAdd")){
      Func = "_add_i32";
    }
    else if(Name.starts_with("FAdd")){
      Func = "_fadd_f32";    
    }
    else if (Name.starts_with("SMin")) {
      Func = "_smin_i32";
    }
    else if (Name.starts_with("SMax")) {
      Func = "_smax_i32";
    }
    else if (Name.starts_with("IMul")) {
      Func = "_mul_i32";
    }
    else if (Name.starts_with("BitwiseOr")) {
      Func = "_or_i32";
    }
    else if (Name.starts_with("BitwiseXor")) {
      Func = "_xor_i32";
    }
    else if (Name.starts_with("BitwiseAnd")) {
      Func = "_and_i32";
    }
    else {
      llvm_unreachable("Unsupported group collective");
    }
    auto MuxName = Prefix + Operation + Func;

    Function *MuxBt;
    if(Scope == 2){
      MuxBt = getOrInsertWorkGroupBT(F->getParent(), MuxName, T);
    } else {
      llvm_unreachable("Unsupported group collective");
    }
    Entry.second = MuxBt;
  }

  for(auto& Entry : WorkList) {
    CallInst *CI = Entry.first;
    Function *F = Entry.second;
    auto *Zero = ConstantInt::get(Type::getInt32Ty(Ctx), 0);
    auto *Arg = CI->getArgOperand(2);
    auto *NewCall = CallInst::Create(F->getFunctionType(), F, {Zero, Arg}, "mux_group_call", CI);
    CI->replaceAllUsesWith(NewCall);
    CI->eraseFromParent();
  }
}

bool replaceGroupCollectives(Module& M) {
  for(auto& F : M) {
  auto FName = F.getName();
  if (!FName.consume_front("_Z"))
    continue;
  FName = FName.drop_while([](char C) { return std::isdigit(C); });
    if(FName.consume_front("__spirv_Group")){
      processGroupCollective(&F, FName);
    }
  }
  return false;
}

struct InstReplacer {
  typedef std::pair<Instruction *, Instruction *> T;
  SmallVector<T> ToRemove;
  void push_back(T a) { ToRemove.push_back(a); }
  void apply() { // todo
    for (auto &El : ToRemove) {
      auto OldI = El.first;
      auto NewI = El.second;
      OldI->replaceAllUsesWith(NewI);
      OldI->eraseFromParent();
    }
  }
};

static bool replaceBarriers(Module &M, bool VSMangling) {
  // DPC++ emits
  //__spirv_ControlBarrier(__spv::Scope Execution, __spv::Scope Memory,
  //                       uint32_t Semantics) noexcept;
  // OCK expects  void __mux_work_group_barrier(i32 %id, i32 %scope, i32
  // %semantics)
  // __spv::Scope is
  // enum Flag : uint32_t {
  //   CrossDevice = 0,
  //   Device = 1,
  //   Workgroup = 2,
  //   Subgroup = 3,
  //   Invocation = 4,
  // };
  auto *SPIRVBarrierFunc =
      M.getFunction(VSMangling ? SPIRVBarrierWin : SPIRVBarrier);
  if (!SPIRVBarrierFunc) {
    // No barriers are found, just return
    return false;
  }
  static auto *MuxBarrierFunc = getMuxBarrierFunc(M);
  InstReplacer ToRemove;
  auto *Zero = ConstantInt::get(Type::getInt32Ty(M.getContext()), 0);
  for (auto &Use : SPIRVBarrierFunc->uses()) {
    auto *I = dyn_cast<CallInst>(Use.getUser());
    if (!I)
      report_fatal_error("Unsupported Value in SYCL Native CPU\n");
    SmallVector<Value *, 3> Args{Zero, I->getArgOperand(0),
                                 I->getArgOperand(2)}; // todo: check how the
                                                       // args map to each other
    auto *NewI = CallInst::Create(MuxBarrierFunc->getFunctionType(),
                                  MuxBarrierFunc, Args, "", I);
    ToRemove.push_back(std::pair(I, NewI));
  }

  ToRemove.apply();

  SPIRVBarrierFunc->eraseFromParent();

  return true;
}

llvm::SmallVector<llvm::Value *>
MakeCallArgs(const std::pair<StringRef, bt_info> &E, Module &M,
             const CallInst &CI) {
  const auto &ArgInfo = E.second;
  switch (ArgInfo.type) {
  case BT_Sig::I64_I32: { // check bt name if required
    auto *Arg =
        ConstantInt::get(Type::getInt32Ty(M.getContext()), ArgInfo.args[0]);
    return {Arg};
  }
  case BT_Sig::I32_I32_I32: {
    return {CI.getArgOperand(0), CI.getArgOperand(1)};
  }
  case BT_Sig::F64_F64_I32:
    return { CI.getArgOperand(0), CI.getArgOperand(1) };
  case BT_Sig::F64_F64_F64_I32:
    return { CI.getArgOperand(0), CI.getArgOperand(1), CI.getArgOperand(2) };
  case BT_Sig::B1_I32_B1: // todo
  case BT_Sig::I32_void:; // todo
  }
  return {};
}

} // namespace

PreservedAnalyses
ConvertToMuxBuiltinsSYCLNativeCPUPass::run(Module &M,
                                           ModuleAnalysisManager &MAM) {
  bool ModuleChanged = false;
  for (auto &F : M) {
    if (F.getCallingConv() == llvm::CallingConv::SPIR_KERNEL) {
      fixFunctionAttributes(&F);
      setIsKernelEntryPt(F);
    }
  }
  const bool VisualStudioMangling = isForVisualStudio(M.getTargetTriple());

  // Then we iterate over all the supported builtins, find their uses and
  // replace them with calls to our Native CPU functions.
  for (auto &Entry : BuiltinNamesMap) {
    auto *Glob = M.getFunction(VisualStudioMangling ? Entry.first.second
                                                    : Entry.first.first);
    if (!Glob)
      continue;
    auto *ReplaceFunc =
        getReplaceFunc(M, Entry.second.first, Entry.second.second.type);
    InstReplacer ToRemove;
    for (auto &Use : Glob->uses()) {
      auto *I = dyn_cast<CallInst>(Use.getUser());
      if (!I)
        report_fatal_error("Unsupported Value in SYCL Native CPU\n");
      const auto Args = MakeCallArgs(Entry.second, M, *I);
      auto *NewI = CallInst::Create(ReplaceFunc->getFunctionType(), ReplaceFunc,
                                    Args, "mux_call", I);
      ModuleChanged = true;
      ToRemove.push_back(std::make_pair(I, NewI));
    }

    ToRemove.apply();

    // Finally, we erase the builtin from the module
    Glob->eraseFromParent();
  }

  ModuleChanged |= replaceBarriers(M, VisualStudioMangling);
  ModuleChanged |= replaceGroupCollectives(M);
  return ModuleChanged ? PreservedAnalyses::none() : PreservedAnalyses::all();
}
